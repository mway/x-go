// Copyright (c) 2022 Matt Way
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE THE SOFTWARE.

package context

import (
	"context"
	"runtime"
	"sync/atomic"
	"time"

	"github.com/pkg/errors"
	"go.mway.dev/chrono/clock"
)

// ErrInvalidTimeout indicates that the given timeout value is invalid.
var ErrInvalidTimeout = errors.New("invalid timeout value provided")

// A DebouncedFactory controls the rate at which contexts with the same
// timeout are generated by memoizing and debouncing them.
//
// DebouncedFactory is intended to be used in situations in which contexts
// (1) are homogeneous (at a minimum, that they have the same timeout); and
// (2) have reasonable lifetimes relative to the debounce period such that
// context leaks are not an issue, which can generally be accomplished by using
// a debounce that is marginally less than the timeout. For example, a debounce
// of 1s with a timeout of 1h can lead to massive context leaks, but a debounce
// of 5s with a timeout of 7s generally will not.
type DebouncedFactory struct {
	ctx       context.Context
	cancel    context.CancelFunc
	fn        TimeoutFunc
	stopwatch clock.Stopwatch
	prev      *contextPair
	debounce  time.Duration
	timeout   time.Duration
	current   atomic.Value
}

// NewDebouncedFactory creates a new DebouncedFactory with the given options
// that uses timeout as the value provided to context.WithTimeout() when
// context creation is not currently being debounced.
func NewDebouncedFactory(
	timeout time.Duration,
	opts ...DebouncedOption,
) (*DebouncedFactory, error) {
	if timeout < 0 {
		return nil, errors.WithMessage(ErrInvalidTimeout, timeout.String())
	}

	options := DefaultDebouncedOptions().With(opts...)
	if err := options.Validate(); err != nil {
		return nil, err
	}

	if options.Debounce > timeout {
		return nil, errors.WithMessagef(
			ErrInvalidDebounce,
			"debounce must be <= timeout (%s vs %s)",
			options.Debounce.String(),
			timeout.String(),
		)
	}

	var (
		ctx, cancel = context.WithCancel(options.Context)
		f           = &DebouncedFactory{
			ctx:       ctx,
			cancel:    cancel,
			debounce:  options.Debounce,
			fn:        options.ContextFunc,
			prev:      &contextPair{},
			timeout:   timeout,
			stopwatch: options.Clock.Stopwatch(),
		}
	)

	f.set(f.fn(ctx, timeout))
	return f, nil
}

// Cancel cancels the DebouncedFactory's internal context. This cancelation
// will cascade to all contexts created by the DebouncedFactory.
func (f *DebouncedFactory) Cancel() {
	f.cancel()
}

// Get returns the current debounced context.Context, creating a new one if
// the configured debounce period has elapsed.
func (f *DebouncedFactory) Get() context.Context {
	var (
		ctx, _ = f.get()
		cancel context.CancelFunc
	)

	if f.stopwatch.Elapsed() >= f.debounce {
		ctx, cancel = f.fn(f.ctx, f.timeout)
		f.cas(ctx, cancel)
		f.stopwatch.Reset()
	}

	return ctx
}

func (f *DebouncedFactory) get() (context.Context, context.CancelFunc) {
	p := f.current.Load().(*contextPair) //nolint:govet,errcheck
	return p.ctx, p.cancel
}

func (f *DebouncedFactory) cas(ctx context.Context, cancel context.CancelFunc) {
	var cur *contextPair
	f.prev, cur = f.current.Load().(*contextPair), f.prev //nolint:govet,errcheck
	cur.ctx = ctx
	cur.cancel = cancel

	for !f.current.CompareAndSwap(f.prev, cur) {
		runtime.Gosched()
	}

	f.prev.ctx = nil
	f.prev.cancel = nil
}

func (f *DebouncedFactory) set(
	ctx context.Context,
	cancel context.CancelFunc,
) {
	f.current.Store(&contextPair{
		ctx:    ctx,
		cancel: cancel,
	})
}

type contextPair struct {
	ctx    context.Context
	cancel context.CancelFunc
}
